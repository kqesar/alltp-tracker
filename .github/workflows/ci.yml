name: CI

on:
  push:
    branches: ["*"]
  pull_request:
    branches: ["*"]
  workflow_call:
    inputs:
      build:
        description: 'Run build step'
        required: false
        type: boolean
        default: false
    outputs:
      test-status:
        description: "Test execution status"
        value: ${{ jobs.ci.outputs.test-status }}
      lint-status:
        description: "Lint execution status"
        value: ${{ jobs.ci.outputs.lint-status }}

permissions:
  contents: read
  checks: write
  pull-requests: write

jobs:
  ci:
    runs-on: ubuntu-latest
    outputs:
      test-status: ${{ steps.test.outcome }}
      lint-status: ${{ steps.lint.outcome }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: '10'

      - name: Install dependencies
        run: pnpm install

      - name: Run linter
        id: lint
        run: pnpm lint

      - name: Run tests with coverage
        id: test
        run: pnpm test:coverage

      - name: Generate coverage summary
        id: coverage
        if: always()
        run: |
          if [ -f coverage/coverage-summary.json ]; then
            echo "Coverage file found, processing..."
            # Extract coverage data using node
            node -e "
              const fs = require('fs');
              try {
                const coverage = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf8'));
                const total = coverage.total;
                console.log('COVERAGE_LINES=' + total.lines.pct);
                console.log('COVERAGE_STATEMENTS=' + total.statements.pct);
                console.log('COVERAGE_FUNCTIONS=' + total.functions.pct);
                console.log('COVERAGE_BRANCHES=' + total.branches.pct);
                console.log('COVERAGE_AVAILABLE=true');
              } catch (e) {
                console.log('COVERAGE_AVAILABLE=false');
                console.log('Error reading coverage:', e.message);
              }
            " >> $GITHUB_ENV
          else
            echo "COVERAGE_AVAILABLE=false" >> $GITHUB_ENV
            echo "Coverage file not found"
          fi

      - name: Build project
        id: build
        if: inputs.build == true
        run: pnpm build

      - name: Comment PR with results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          COVERAGE_AVAILABLE: ${{ env.COVERAGE_AVAILABLE }}
          COVERAGE_LINES: ${{ env.COVERAGE_LINES }}
          COVERAGE_STATEMENTS: ${{ env.COVERAGE_STATEMENTS }}
          COVERAGE_FUNCTIONS: ${{ env.COVERAGE_FUNCTIONS }}
          COVERAGE_BRANCHES: ${{ env.COVERAGE_BRANCHES }}
        with:
          script: |
            const lintStatus = '${{ steps.lint.outcome }}' === 'success' ? '‚úÖ' : '‚ùå';
            const testStatus = '${{ steps.test.outcome }}' === 'success' ? '‚úÖ' : '‚ùå';
            
            let buildRow = '';
            if ('${{ inputs.build }}' === 'true') {
              const buildOutcome = '${{ steps.build.outcome }}';
              const buildStatus = buildOutcome === 'success' ? '‚úÖ' : buildOutcome === 'skipped' ? '‚è≠Ô∏è' : '‚ùå';
              buildRow = `| Build | ${buildStatus} |`;
            }

            // Coverage section
            let coverageSection = '';
            if (process.env.COVERAGE_AVAILABLE === 'true') {
              const lines = process.env.COVERAGE_LINES;
              const statements = process.env.COVERAGE_STATEMENTS;
              const functions = process.env.COVERAGE_FUNCTIONS;
              const branches = process.env.COVERAGE_BRANCHES;
              
              const getCoverageEmoji = (pct) => {
                const num = parseFloat(pct);
                if (num >= 90) return 'üü¢';
                if (num >= 80) return 'üü°';
                if (num >= 70) return 'üü†';
                return 'üî¥';
              };
              
              coverageSection = `
            ## üìä Test Coverage

            | Metric | Coverage | Status |
            |--------|----------|--------|
            | Lines | ${lines}% | ${getCoverageEmoji(lines)} |
            | Statements | ${statements}% | ${getCoverageEmoji(statements)} |
            | Functions | ${functions}% | ${getCoverageEmoji(functions)} |
            | Branches | ${branches}% | ${getCoverageEmoji(branches)} |

            `;
            } else if ('${{ steps.test.outcome }}' === 'success') {
              coverageSection = `
            ## üìä Test Coverage
            
            ‚ö†Ô∏è Coverage data not available
            
            `;
            }

            const hasFailures = lintStatus === '‚ùå' || testStatus === '‚ùå' || 
              ('${{ inputs.build }}' === 'true' && '${{ steps.build.outcome }}' === 'failure');

            const comment = `## üîç CI Results

            | Check | Status |
            |-------|--------|
            | Linting | ${lintStatus} |
            | Tests | ${testStatus} |
            ${buildRow}
            ${coverageSection}
            ${hasFailures ? '‚ùå Some checks failed. Please review the logs above.' : '‚úÖ All checks passed!'}

            ---
            *Updated at ${new Date().toISOString()}*`;

            // Find existing CI comment and update it, or create new one
            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            const existingComment = comments.find(comment => 
              comment.body.includes('üîç CI Results') && 
              comment.user.type === 'Bot'
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                comment_id: existingComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
